#!/usr/bin/env bash

# Syntaxe :
# - : pas d'argument nécessaires
# Fonctionnement : 
# Ce script retourne la dernière commande et ses arguments avec 'echo'.
# La commande est retournée entre guillemets simples.
# Pour l'utiliser, il faut les retirer avec sed (guillemet début + fin)
# Puis faire :
#       eval ${DERNIERE_COMMANDE[*]}
# Elle peut ainsi être réutilisée tel quel par un autre programme.
# Pr un exemple d'utilisation - cf le script.

# Exemple d'utilisation de ce script pr run la commande :
# Obtention de la dernière commande
#       DERNIERE_COMMANDE="$(commande_derniere_obtenir)"
# Retrait des guillemets de début et fin
#       DERNIERE_COMMANDE="$(echo "$DERNIERE_COMMANDE" | sed -e "s/'$//" )"
#       DERNIERE_COMMANDE="$(echo "$DERNIERE_COMMANDE" | sed -e "s/^'//" )"
# Run de la dernière commande
#       eval ${DERNIERE_COMMANDE[*]}
# Exemple de retransmission tel quel à un autre script pr qu'il run la commande :
#       DERNIERE_COMMANDE="$(commande_derniere_obtenir)"
#       echo "$DERNIERE_COMMANDE"
# pas besoin de remettre entre guillemets simples car ils sont conservés.

# Obtenir le décalage de la ligne recherchée dans l'historique.
# Principe : Compter le nb de lignes entre le début de l'historique et la ligne
# qui effectue la recherche dans l'historique (celle-ci faisant elle-même partie de l'historique).
# Les lignes vides sont déduites ensuite car elles ne sont pas affichées dans l'historique.
# Finalement, +1 ligne car le décalage doit inclure la ligne qui a été écrite dans l'historique juste avant 
# C'est-à-dire la ligne de la dernière commande.
REGEX_LIGNE_DEBUT_HISTORIQUE="^history -r ~/.bash_history.*"
LIGNE_DEBUT_HISTORIQUE="$(grep -E -n "$REGEX_LIGNE_DEBUT_HISTORIQUE" "$0")"
NUM_LIGNE_DEBUT_HISTORIQUE="$(echo "$LIGNE_DEBUT_HISTORIQUE" | awk -F : ' { print $1} ' )"
REGEX_LIGNE_QUI_EFFECTUE_RECHERCHE="^LIGNE_AVEC_DERNIERE_COMMANDE.*"
LIGNE_QUI_EFFECTUE_RECHERCHE="$(grep -E -n "$REGEX_LIGNE_QUI_EFFECTUE_RECHERCHE" "$0")"
NUM_LIGNE_QUI_EFFECTUE_RECHERCHE="$(echo "$LIGNE_QUI_EFFECTUE_RECHERCHE" | awk -F : ' { print $1} ' )"
NB_LIGNES_ENTRE_DEUX=$((NUM_LIGNE_QUI_EFFECTUE_RECHERCHE-NUM_LIGNE_DEBUT_HISTORIQUE)) # le décalage compte le nb de ligne depuis l'activation de l'historique
NB_LIGNES_VIDE=$(grep -A $NB_LIGNES_ENTRE_DEUX "$REGEX_LIGNE_DEBUT_HISTORIQUE" "$0" | grep -c "^$")
DECALAGE=$((NB_LIGNES_ENTRE_DEUX-NB_LIGNES_VIDE+1))
# '+1' car on doit aussi récupérer la ligne qui précède = elle est la précédente commande.
# '-NB_LIGNES_VIDE' car elles ne sont pas affichées dans l'historique

# Activation de l'historique et configuration de son contenu sur la base du fichier bash_history
set -o history # activer les fonctionnalité d'accès à l'historique
history -r ~/.bash_history # charger l'historique depuis le fichier de l'historique
# Recherche de la ligne de la dernière commande dans l'historique (avec le numéro)
LIGNE_AVEC_DERNIERE_COMMANDE="$(history | tail -n $DECALAGE | head -n 1)" # récupère les X dernières lignes de l'historique
# La première du bloc est celle de la dernière commande avant ce script.

# Suppression du numéro (dû à l'historique) devant la ligne de la dernière commande.
DERNIERE_COMMANDE="$(echo "$LIGNE_AVEC_DERNIERE_COMMANDE" | awk ' {for (i=2; i<=NF; i++) {printf ("%s ",$i) } } END { print "" } ')"
# Suppression des éventuels espaces de fin
DERNIERE_COMMANDE="$(echo "$DERNIERE_COMMANDE" | sed -e 's/[[:space:]]*$//' )"

# Affichage de la dernière commande avec echo.
# La commande est transmise entre guillemets simple car elle peut contenir
# des caractères spéciaux dont il faut annuler la valeur
# tel que '|' dans les pipelines.
# Elle peut ainsi être réutilisée par un autre programme.
echo "'${DERNIERE_COMMANDE}'"
