#!/usr/bin/env bash

# Syntaxe :
# $1 : COMMANDE : string éventuellement (si requis) arguments entre guillemets simples/doubles
# $... : ARGUMENT_OPTIONNELS (optionnel) string éventuellement (si requis) arguments entre guillemets simples/doubles
# $DERNIER : '-inc=PLUS_OU_MOINS_INCREMENT' (optionnel) '-inc' suivi de '=' suivi d'un nombre entre -20 et +19
# Remarques :
# Pour accélérer un processus, il faut lui faire passer un incrément négatif.
# Le maximum d'accélération est -20. Le minimum est +19.
# Par défaut, un processus possède un 'nice' de 0 (cf 'man nice').

# Fonctionnement :
# Le script va runner la commande en arrière plan tout en redirigeant l'output vers un fichier dans la corbeille (pour éventuelle lecture).
# Un fois la commande runnée, il va en modifier la priorité.
# Si elle doit être accru, il faudra sudo et donc saisir le mot de passe.

source fonctions_personnelles

SYNTAXE="\nSyntaxe :\n\t$(basename $0)    COMMANDE    [ARGUMENT_OPTIONNELS ...]    [-inc=PLUS_OU_MOINS_INCREMENT]\n"
NOM_OUTPUT_CORBEILLE="$(basename $0)_output.txt"
FICHIER_OUTPUT_CORBEILLE=~/.Trash/$NOM_OUTPUT_CORBEILLE
# Gestion des regexs utilisé pour vérifié si le dernier argument est syntaxé comme un incrément
# et si c'est le cas si sa dernière partie (après le 'égal') contient un nombre
# Ici nb entier inclus entre -29 et +29
REGEX_NB_ENTIER_POSITIF_OU_NEGATIF="^[+-]?[0-2]{1}[0-9]?$"
REGEX_INCREMENT_EGAL_NB="^-inc=[+-]?[0-2]{1}[0-9]?$"
# [] : liste d'items pouvant matcher (un seul de la liste)
# ? : match 0 ou 1 fois
# {1} : match exactement une fois


# Contrôle des arguments
declare -a TABLEAU_ARGUMENT
# Test si au moins un argument.
if [ -z "$1" ]
then
    echo -e "\nERREUR : aucun argument fourni."
    echo -e "$SYNTAXE"
    exit 1
else
    # Stockage des argument dans un tableau sauf le dernier pour lequel
    # Il faut contrôler s'il est syntaxé comme un incrément, sinon il sera considéré comme un argument de plus.
    NB_ARGUMENT=$#
    INDEX_DERNIER_ARGUMENT=$((NB_ARGUMENT))
    DERNIER_ARGUMENT="${!INDEX_DERNIER_ARGUMENT}"
    for ((i=1; i<$((NB_ARGUMENT)); i++))
    do
        TABLEAU_ARGUMENTS+=("${!i}")
    done
    
    # Si dernier argument match '-increment=NB' alors considéré comme increment.
    # Sinon considéré comme un argument.
    if [[ "$DERNIER_ARGUMENT" =~ $REGEX_INCREMENT_EGAL_NB ]]
    then
        INCREMENT="$(echo "$DERNIER_ARGUMENT" | awk -F = ' { print $2} ')"
        # Si un incrément est présent, il doit matcher le REGEX (nombre entre -29 et +29)
        if [[ "$INCREMENT" =~ $REGEX_NB_ENTIER_POSITIF_OU_NEGATIF ]] &&
        # Et s'il matche, contrôle s'il est inclus entre les extremums (-20 et +19)
        [[ $((INCREMENT)) -ge -20 && $((INCREMENT)) -le 19 ]]
        then
            : # OK continue script
        else
            echo -e "\nERREUR : le deuxième argument \"$INCREMENT\" n'est pas un nombre inclus entre -20 et +19 (avec signe éventuel)."
            echo -e "$SYNTAXE"
            exit 1
        fi
    else
        # Sinon, le dernier argument est considéré comme un argument et non comme un incrément
        # Par défaut, si pas précisé, l'incrément est -20 (priorisation maximum).
        INCREMENT="-20"
        TABLEAU_ARGUMENTS+=("$DERNIER_ARGUMENT")
    fi
fi

# Préparation de la commande en concaténant les arguments
COMMANDE=""
for ELEMENT in "${TABLEAU_ARGUMENTS[@]}"
do
    COMMANDE="${COMMANDE}${ELEMENT} "
done

# Lancement de la commande en arrière plan pour permettre le reste du script de fonctionner
TEMPS_D_ATTENTE_ENTRE_MESSAGE_ET_LANCEMENT=1
echo -e "\nLancement de la commande \"$COMMANDE\" dans $TEMPS_D_ATTENTE_ENTRE_MESSAGE_ET_LANCEMENT secondes.\n"
echo -e "Une copie de l'output de la commande a été placée dans la corbeille sous le nom de \"$NOM_OUTPUT_CORBEILLE\".\n"
sleep $TEMPS_D_ATTENTE_ENTRE_MESSAGE_ET_LANCEMENT

# Sortie redirigée vers le fichier de la corbeille
$COMMANDE > $FICHIER_OUTPUT_CORBEILLE 2>&1 & # l'output placé dans un fichier dans la corbeille
# car sinon, je ne peux pas sudo en fournissant le MDP et donc je ne peux pas modifier la priorité (l'améliorer.)

# Recherche du numéro de processus (PID) correspondant à la commande lancée
REGEX_RECHERCHE_COMMANDE="^$COMMANDE[[:space:]]*[0-9]+$"
# Débute exactement par la commande '^'
# Puis est suivi d'un nombre d'espace quelconque (*)
# Et se termine par un nombre (range 0-9 '+' pr une fois ou plus)
# Puis une fin de ligne '$'
# Ceci garantit qu'aucun autre processus sera concerné que celui qui a été lancé.
# Récupère le PID de la commande
PID_ET_NOM_COMMANDE="$(ps -A -o command,pid |
                # ps -A : obtient la liste de tous les processus
                # ps -o : obtient que certaines colonnes (ici, le nom de la commande et le PID - dans cet ordre)
                grep -E "$REGEX_RECHERCHE_COMMANDE" )"
                # grep -E : extended regex

if [ -z "$PID_ET_NOM_COMMANDE" ]
then
    echo -e "\nLa commande :\n$COMMANDE\nest déjà terminée. Il n'est plus nécessaire de modifier sa priorité.\n"
else
    # Récupération du PID : il est le dernier élément
    PID_COMMANDE="$(echo "$PID_ET_NOM_COMMANDE" | awk ' { print $NF } ' )"
    MESSAGE_REUSSITE="\nLa priorité (niceness) de la commande :\n\t$COMMANDE\n\tPID : $PID_COMMANDE\na été modifiée de $INCREMENT.\n"
    MESSAGE_ECHEC="\nÉCHEC : La priorité (niceness) de la commande :\n\t$COMMANDE\nn'a pas pu être modifiée de $INCREMENT.\n"
    # Adaptation de la priorité du processus
    if [ $((INCREMENT)) -lt 0 ]
    then
        # Pour une diminution (priorisation du processus), besoin d'être root sinon c'est refusé.
        sudo renice -n "$INCREMENT" "$PID_COMMANDE" || { echo -e "$MESSAGE_ECHEC" ; exit 1 ; }
    else
        # Pour une augmentation (dé-priorisation du processus), pas besoin d'être root.
        renice -n "$INCREMENT"  "$PID_COMMANDE" || { echo -e "$MESSAGE_ECHEC" ; exit 1 ; }
    fi
    echo -e "$MESSAGE_REUSSITE"
    echo -e "Affichage du nouvel état :"
    # Affichage de l'entête
    ps -Al | head -n 1
    ps -Al | grep "$PID_COMMANDE" | grep -v "grep"
    # -v : match ceux qui ne matche pas 'grep' 

    # Lecture optionnel de l'output de la commande avec 'less'
    REPONSE=""
    QUESTION="Souhaiteriez-vous ouvrir l'output avec 'less' ? (YyOo/Nn) "
    question_oui_non REPONSE "$QUESTION"
    if [ "$REPONSE" = "o" ]
    then
        less "$FICHIER_OUTPUT_CORBEILLE"
    else
        :
    fi
fi


