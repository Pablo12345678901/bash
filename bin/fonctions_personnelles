#!/usr/bin/env bash

# Ranger par ordre alphabétique pour éviter doublons
# Donner noms complexes pour éviter doublon avec fonction déjà dans bash

# A

function app_fermer_normal {
if [ -z "$1" ]
then
    echo "ERREUR : aucune app transmise en argument."
    exit 1
else
    local -n APP=$1
    osascript -e "quit app \"$APP\"" && # osascript est spécial et pour Apple - besoin de protéger le nom de l'app entre guillemets
    echo "$APP fermée..." ||
    {   echo -e "\nERREUR : l'application $APP n'a pas pu être fermée.\n" ;
        exit 1 ;
    }
fi
}


function app_fermer_brutal {
if [ -z "$1" ]
then
    echo "ERREUR : aucune app transmise en argument."
    exit 1
else
    local -n APP=$1
    pkill -x "$APP" && echo "$APP fermée de manière forcée..." ||
    {   echo -e "\nERREUR : l'application $APP n'a pas pu être fermée de manière forcée.\n" ;
        exit 1 ;
    }
fi
}

# B

# C

function calculatrice_appel_script {
    calculatrice_avec_ou_sans_affichage $*
}

# D

# E

# F

# G

# H

# I

# J

# K

# L

# M

function module_controle_si_present_sinon_installe {
    # $1 : module à installer par brew
    # La fonction retourne une valeur qui faut contrôler :
    # 0 : réussite de l'installation / déjà installé
    # 1 : échec de l'installation.
    MODULE_NECESSAIRE="$1"
    which "$MODULE_NECESSAIRE" >/dev/null # non affichage du résultat de la recherche
    if (($?))
    then
        echo -e "\nInstallation de '$MODULE_NECESSAIRE' (requis pour ce script).\n"
         brew install "$MODULE_NECESSAIRE" &&
        { echo -e "\nInstallation terminée.\n" && return 0 ; } ||
        { echo -e "\nERREUR : installation échouée.\n" && return 1 ; }
    else
        return 0 # si déjà installé
    fi
}

# N

# O

# P

# Q

function question_oui_non {
    local -n REP_UTILISATEUR=$1
    local -n QUE_POSEE="$2"
    # Type réponse retournée : 'o' ou 'n'
    echo "" # esthétique
    read -p "$QUE_POSEE" CHO
    case "$CHO" in
        [OoYy]  )   CHO='o';;
        [Nn]    )   CHO='n';;
        *       )   echo -e "\nERREUR : veuillez saisir une réponse parmi :\n\"OoYy\" pour \"Oui\"\n\"Nn\" pour \"Non\""
                    question_oui_non $1 "$2" # appel récursif de la fonction tant que la réponse n'est pas oui ou non - similaire à une boucle
        ;;
    esac
    REP_UTILISATEUR=$CHO
}

# R

function remplissage_tableau_app_ouverte {
local -n tableau=$1 # variable liée à la variable globale du tableau des app ouvertes

# Osacript fonctionne sur Mac uniquement (non portable)
LISTE_STRING_APP_OUVERTES=$(osascript -e 'set text item delimiters to ":"' -e 'tell application "System Events" to (name of every application process whose background only is false) as string' | sort )

# Séparation des éléments par des ":" pour futur split avec ":"
SPECIAL_CHAR_SEPARATOR=':'
LISTE_STRING_APP_OUVERTES=${LISTE_STRING_APP_OUVERTES/Terminal/} # Tout fermer sauf Terminal - retiré Terminal de la liste des apps à fermer
# VS CODE, décommenter la ligne ci-dessous, sinon l'app se fermera.
#LISTE_STRING_APP_OUVERTES=${LISTE_STRING_APP_OUVERTES/Electron/} # et Vs Code pour coder
# Microsoft Word, décommenter la ligne ci-dessous, sinon l'app se fermera.
#LISTE_STRING_APP_OUVERTES=${LISTE_STRING_APP_OUVERTES/Microsoft\ Word/} # et Word pour prendre des notes
LISTE_STRING_APP_OUVERTES=${LISTE_STRING_APP_OUVERTES//$SPECIAL_CHAR_SEPARATOR$SPECIAL_CHAR_SEPARATOR/$SPECIAL_CHAR_SEPARATOR} # remplacement du délimiteur double par un simple suite à la suppression de l'app Terminal de la liste des apps à fermer

# Formatage du string à spliter : suppression des leading and trailing space, suppression des éventuels doubles points avant et après
LISTE_STRING_APP_OUVERTES=$(sed -e 's/[[:space:]]*$//' <<< $LISTE_STRING_APP_OUVERTES)
LISTE_STRING_APP_OUVERTES=$(sed -e 's/^[[:space:]]*//' <<< $LISTE_STRING_APP_OUVERTES)
LISTE_STRING_APP_OUVERTES=$(sed -e 's/^://' <<< $LISTE_STRING_APP_OUVERTES)

# Splitter le string en tableau selon un séparateur spécial
OLDIFS=$IFS # conservation de la valeur d'origine du séparateur IFS
IFS=: # le séparateur est désormais ":""
TABLEAU_APP_OUVERTES=($LISTE_STRING_APP_OUVERTES) # split du string en tableau selon le nouveau séparateur
IFS=$OLDIFS # remise de IFS à son ancienne valeur
}


function retourne_choix_si_nb_correct_selon_select {
local -n TABLEAU=$1
local -n ARG_FOURNI=$2
local -n CHOIX=$3
local -n MESSAGE=$4 # Message pour expliquer l'argument à fournir ("range des choix entre 1 et MAX")
# Argument optionnel $5 = option_quitter
TABLEAU_COPIE=("${TABLEAU[@]}")             
# Ajout de l'option quitter à la liste si fourni
if [ -n "$5" ] 
then
    local -n OPTION_QUITTER=$5
    TABLEAU_COPIE+=("$OPTION_QUITTER")
else
    :
fi

NB_REGEX='^[0-9]+$' # Utile pour tester les index
if [[ "$ARG_FOURNI" =~ $NB_REGEX ]]
then
    if [ "$ARG_FOURNI" -gt 0 -a "$ARG_FOURNI" -le ${#TABLEAU_COPIE[@]} ]
    then
        CHOIX="${TABLEAU_COPIE[(($ARG_FOURNI-1))]}" # décalage de l'index car les choix à select débutent à 1 et pas 0
    else
        echo -e "\nERREUR : le numéro fourni en argument \"$ARG_FOURNI\" ne fait pas partie de la liste des choix.\n"
        exit 1
    fi
else
    echo -e "\nL'argument \"$ARG_FOURNI\" n'est pas valable."
    echo -e "$MESSAGE\n"
    exit 1
fi
}

# S

function select_parmi_liste {
# arguments à fournir dans l'ordre :
# $1 : TAB_D_OPTIONS
# $2 : CH_UTILISATEUR
# $3 : MES_AFFICHE -> avant d'afficher les choix
# $4 : optionnel : OPT_POUR_ARRETER
local -n TAB_D_OPTIONS=$1
local -n CH_UTILISATEUR=$2
local -n MES_AFFICHE=$3 # Message
MESSAGE_BOUCLE=""
if [ -z "$4" ] # si le 4ème paramètre est défini = si options pour arrêter a été fournie
then    
    TABLEAU_CHOIX=("${TAB_D_OPTIONS[@]}") # copie du tableau original (à conserver)    
else
    local -n OPT_POUR_ARRETER=$4 # optionnel
    TABLEAU_CHOIX=("${TAB_D_OPTIONS[@]}") # copie du tableau original car je vais y ajouter l'option de sortie
    TABLEAU_CHOIX+=("$OPT_POUR_ARRETER") # ajout de l'option de sortie
    DERNIERE_OPTION="${#TABLEAU_CHOIX[@]}"
    MESSAGE_SI_OPTION_QUITTER="Tapez \"$DERNIERE_OPTION\" pour \"$OPT_POUR_ARRETER\"
    " # inclus un retour à la ligne
fi

CH_UTILISATEUR=""
until [ -n "$CH_UTILISATEUR" ] 
do
    echo -e "\n$MES_AFFICHE.\n$MESSAGE_SI_OPTION_QUITTER"
    select CH_UTILISATEUR in "${TABLEAU_CHOIX[@]}"
    do
        break 
    done
    if [ -n "$CH_UTILISATEUR" ] # si le choix est correct
    then
        :
    else
        echo -e "ERREUR : votre saisie ne fait pas partie de la liste de choix.\n$MESSAGE_SI_OPTION_QUITTER"
    fi
done   

}

# T

function tableau_affichage_contenu_avec_message {
local -n TAB=$1
MES="" # message
if [ -z "$2" ]
then
    :  
else
    MES="$2"
fi

# Affichage du contenu tableau que s'il y a au moins un élément
if [ 0 -lt ${#TAB[@]} ]
then
    echo "" # retour à la ligne esthétique
    echo -e "$2"
    for ELEMENT in "${TAB[@]}"
    do
        echo "$ELEMENT"
    done
    echo ""
else
    :
fi
}


# ajout_element_tableau : argument 1 = tableau / argument 2 = élément à ajouter
function tableau_ajout_element_que_si_non_existant_avec_espaces {
    # $1 : NOM_DE_LA_VARIABLE_TABLEAU
    # $2 : STRING_ELEMENT_A_AJOUTER
    if [[ -z "$1" || -z "$2" ]]
    then
        echo "ERREUR : les arguments \$1 : nom_du_tableau_en_string et \$2 : élément à ajouter au tableau n'ont pas été fourni tous les 2."
    else
        local -n TAB=$1
        # Contrôle si l'élément est déjà dans le tableau et ajout s'il n'y est pas.
        ELEMENT_DEJA_DANS_TABLEAU="false"
        # Comme les éléments peuvent contenir des espaces, besoin de boucler sur chacun
        # Et de les comparer un par un au string fourni pour ajout.
        for element in "${TAB[@]}"
        do
            if [ "$element" == "$2" ]
            then
                # Si l'élément est dans le tableau, on change l'indicateur à 'true' et sort de la boucle.
                ELEMENT_DEJA_DANS_TABLEAU="true"
                break
            else
                :
            fi
        done
        # Ajout de l'élément que si l'indicateur est à "non true" donc à "false".
        if [ $ELEMENT_DEJA_DANS_TABLEAU == "true" ]
        then
            : # si l'élément est déjà dans le tableau on ne le rajoute pas
        else
            TAB+=("$2")
        fi
    fi
}


# ajout_element_tableau : argument 1 = tableau / argument 2 = élément à ajouter
function tableau_ajout_element_que_si_non_existant_sans_espaces {
    # $1 : NOM_DE_LA_VARIABLE_TABLEAU
    # $2 : STRING_ELEMENT_A_AJOUTER
    if [[ -z "$1" || -z "$2" ]]
    then
        echo "ERREUR : les arguments \$1 : nom_du_tableau_en_string et \$2 : élément à ajouter au tableau n'ont pas été fourni tous les 2."
    else
        local -n TAB=$1
        # Contrôle si l'élément est déjà dans le tableau et ajout s'il n'y est pas.
        if [[ " ${TAB[*]} " =~ " ${2} " ]]
        # Les éléments sont séparés par des espaces.
        # Sauf en début et fin.
        # Donc pour contrôler le REGEX, ajout d'espace avant et après.
        then
            : # si l'élément est déjà dans le tableau on ne le rajoute pas
            #DEBUG echo "PAS d'ajout car $2 déjà dans tableau".
        else
            #DEBUG echo "Ajout car $2 pas encore dans tableau".
            TAB+=("$2")
        fi
    fi
}


function tableau_supprimer_tous_les_occurences_d_un_element {
#   $1 : le tableau
#   $2 : l'élément à supprimer entre guillemets si nécessaire
    local -n TAB=$1
    local ELE="$2" # element à supprimer
    echo "ELE $ELE"
    for ELEMENT in "${TAB[@]}"
    do
        for INDEX in "${!TAB[@]}" # besoin de l'index pour unset la variable
        do
            if [[ "${TAB[$INDEX]}" = "$ELE" ]]
            then
                unset -v TAB[$INDEX]
                echo "$?"
            fi
        done
    done
}


# U
 
# V

# W

# X

# Y

# Z