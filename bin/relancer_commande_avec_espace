#!/usr/bin/env bash

# Syntaxe :
# $1 : NB_LIGNE_ESPACE (optionnel)

# Adapter ici le nombre de ligne vide par défaut si non défini.
NB_LIGNE_ESPACE_PAR_DEFAUT=10

# Contrôle qu'un argument a été fourni au script
if [ -z "$1" ]
# $1 : le nombre de ligne vide à printer avant de relancer la précédente commande.
then
    # Nb d'espace par défaut, si pas de nb d'espace fourni.
    NB_LIGNE_ESPACE=$NB_LIGNE_ESPACE_PAR_DEFAUT
    echo -e "\nAucun argument fourni."
    echo "Fonctionnement par défaut :"
    echo "Relancement de la commande précédente avec $NB_LIGNE_ESPACE lignes vides avant."
else
    # Test si entier plus grand que 0
    re='^[1-9]+[0-9]*$'
    if [[ $1 =~ $re ]] # si l'argument fourni est un nombre
    then
        NB_LIGNE_ESPACE=$1
        echo -e "\nRelancement de la commande précédente avec $NB_LIGNE_ESPACE lignes d'espaces avant."
        
    else
        # Nb d'espace par défaut, si mauvais argument fourni.
        NB_LIGNE_ESPACE=$NB_LIGNE_ESPACE_PAR_DEFAUT
        echo -e "\nERREUR : l'argument \"$1\" fourni n'est pas un nombre > 0."
        echo "Fonctionnement par défaut :"
        echo "Relancement de la commande précédente avec $NB_LIGNE_ESPACE lignes vides avant."
    fi
fi





# Imprime NB_LIGNE_ESPACE avant de relancer la commande précédente
espace_print_nb $NB_LIGNE_ESPACE

############ AVERTISSEMENT ############
# Ne pas modifier le code ci-dessous car le moindre décalage d'une ligne ferait exécuter une autre commande.
#######################################
# Récupération de la commande précédente
set -o history # activer les fonctionnalité d'accès à l'historique
history -r ~/.bash_history # charger l'historique depuis le fichier de l'historique
# Ligne à rechercher dans l'historique
LIGNE_A_RECHERCHER="# Ligne à rechercher dans l'historique" # Elle correspond à la ligne précédente
LIGNE_AVEC_NUMERO_UNIQUE="$(grep -B 10 "$LIGNE_A_RECHERCHER" < <(history | tail -n 10) | # récupère les 10 dernières lignes de l'historique
tail -n 1)" # y recherche la ligne la récupère -> elle est unique car elle possède un numéro unique devant
# LIGNE CLEF CI-DESSOUS
DERNIER_COMMANDE="$(grep -B5 "$LIGNE_AVEC_NUMERO_UNIQUE" < <(history | tail -n 10) | # recherche la ligne en question, affiche les NUM lignes d'avant (NUM = décalage exact = IMPORTANT) 
# LIGNE CLEF CI-DESSUS
head -n 1 | # récupère la ligne (commande + numéro)
awk ' {for (i=2; i<=NF; i++) {printf $i " "} } END { print "" } ' )" # affiche la ligne complète sauf le premier mot (= le numéro de ligne)
bash -c "$DERNIER_COMMANDE"
############ AVERTISSEMENT ############
# Ne pas modifier le code ci-dessus car le moindre décalage d'une ligne ferait exécuter une autre commande.
#######################################

