## DEBUT GUIX

# Set up Guix Home profile
if [ -f ~/.profile ]; then . ~/.profile; fi

# Honor per-interactive-shell startup file
if [ -f ~/.bashrc ]; then . ~/.bashrc; fi

# Merge search-paths from multiple profiles, the order matters.
eval "$(guix package --search-paths \
-p $HOME/.config/guix/current \
-p $HOME/.guix-profile \
-p /run/current-system/profile)"

### FIN GUIX ### IL RESTE DES PATHS GUIX CI-DESSOUS ###


# VARIABLE A ADAPTER ICI
: ${BUREAU_PATH:="$HOME/Desktop"}
: ${REPERTOIRE_DEVELOPPEMENT:="$BUREAU_PATH/developpement"}
: ${REPERTOIRE_DES_COMMANDES_PERSO:="$REPERTOIRE_DEVELOPPEMENT/bash/bin"}
# Source le fichier ou je conserve mes fonctions personnelles
# Je l'ai placé dans l'environnement de développement pour faciliter ses modifications.
# Ainsi je peux appeler les fonctions depuis n'importe quel terminal / fichier.
# Toutefois, je dois continuer de sourcer le fichiers dans mes scripts.
. $REPERTOIRE_DES_COMMANDES_PERSO/fonctions_personnelles # source les fonctions personnelles

# Contrôle pour ne pas run ce script par moi-même via mes commandes personnelles.
if [[ $0 =~ (-)?bash$ ]] # "-bash" est run au lancement et "bash" est run avec "exec bash -l" qui relance bash
then
    :
else
    CE_FICHIER="$0"
    COMMANDE_APPELEE=$(basename $CE_FICHIER) # Obtention du nom du fichier en supprimant le reste du path
    echo -e "\nErreur : vous ne devez pas run la commande (script) \"$COMMANDE_APPELEE\" car ce script est une copie du profil de Bash sauvegardée dans le fichier .profile et sert uniquement à la sauvegarde pour être réutilisée en cas de changement d'environnement.\n"
    exit 1 # exit du fichier si ce n'est pas le shell qui le run à l'ouverture
    # c'est-à-dire : exit du fichier si je le run sous le nom donné ci-dessous en tant que commande du dossier personnel.
fi





# Fonction pour éviter un ajout de path à double dans $PATH
################################
# _remove $1 from PATH
function _path_del() {
    local -n VAR_A_MODIF_DEL=$1
    local _l=":$VAR_A_MODIF_DEL:"
    # $2 = path à supprimer
    while [[ $_l =~ :$2: ]]; do
          _l=${_l//:$2:/:}
    done
    _l=${_l%:}
    _l=${_l#:}
    VAR_A_MODIF_DEL="$_l"
}

# _prepend : prepend $1 to PATH.
function _path_prepend() {
    local -n VAR_A_MODIF_PREPEND=$1
    # $2 : le path à ajouter
    _path_del PATH "$2"
    VAR_A_MODIF_PREPEND="$2:$VAR_A_MODIF_PREPEND"
}

# _append : append $1 to PATH.
function _path_append() {
    local -n VAR_A_MODIF_APPEND=$1
    # $2 : le path à ajouter
    _path_del VAR_A_MODIF_APPEND "$2"
    if [ -z "$VAR_A_MODIF_APPEND" ] # if lenght is 0
    then
        VAR_A_MODIF_APPEND="$2" # adding path without separator
    else
        VAR_A_MODIF_APPEND="$VAR_A_MODIF_APPEND:$2" # adding path with separator ':' before
    fi
}

# ajout_element_tableau : argument 1 = tableau / argument 2 = élément à ajouter
function ajout_au_tableau() {
    if [[ -z "$1" || -z "$2" ]]
    then
        echo "ERREUR : les arguments \$1 : nom_du_tableau_en_string et \$2 : élément à ajouter au tableau n'ont pas été fourni tous les 2."
    else
        local -n tableau=$1
        # Contrôle si l'élément est déjà dans le tableau et ajout s'il n'y est pas.
        if [[ " ${tableau[*]} " =~ " ${2} " ]]
        # Les éléments sont séparés par des espaces.
        # Sauf en début et fin.
        # Donc pour contrôler le REGEX, ajout d'espace avant et après.
        then
            : # si l'élément est déjà dans le tableau on ne le rajoute pas
        else
            tableau+=("$2")
        fi
    fi
}


# Fonctions diverses :
# X



################################
# Liste variables d'environnement personnelles (créées par moi)
# REPERTOIRE_DEVELOPPEMENT est déjà défini ci-dessus
export REPERTOIRE_DEVELOPPEMENT # pour utilisation (notamment) durant les push de Git

# REPERTOIRE_DES_COMMANDES_PERSO est déjà défini ci-dessus
export REPERTOIRE_DES_COMMANDES_PERSO # pour utilisation dans le script qui sauvegarde ce profil
REPERTOIRE_ADMINISTRATIF="$REPERTOIRE_DEVELOPPEMENT/administratif"
export REPERTOIRE_ADMINISTRATIF

# Pour lesspipe, une extension utile à la commande less de Bash
#LESSOPEN="|/usr/local/bin/lesspipe.sh %s"
#export LESSOPEN

# Pour la commande ajouter la database locale à la commande locate
#DB_LOCALE="$HOME/locate.user.database"
#export DB_LOCALE

# Pour la gestion des keybinds (raccourcis clavier) de la commande 'bind'
#RACCOURCIS_CLAVIER="$REPERTOIRE_DES_COMMANDES_PERSO/#bind_gestion_raccourci_clavier.txt"
#export RACCOURCIS_CLAVIER

# Path du fichier de profil bash
BASH_PROFILE_PATH="$HOME/.bash_profile"
export BASH_PROFILE_PATH

# Path du fichier bashrc
BASHRC_PATH="$HOME/.bashrc"
export BASHRC_PATH

# Path du bureau
# BUREAU_PATH est déjà défini ci-dessus
export BUREAU_PATH

# Path de la corbeille 
#CORBEILLE_PATH="trash:///"
#export CORBEILLE_PATH

# Path de connexion des ports usb locaux
USB_CONNEXION_PATH="/media/${USER}"
export USB_CONNEXION_PATH

# Pour GUIX
GUIX_PROFILE="/home/incognito/.guix-profile"
. "$GUIX_PROFILE/etc/profile" # charger le guix profile 
export GUIX_PROFILE


# Tableau des variables personnelles 
declare -a TABLEAU_VARIABLES_PERSO # tableau des paths à ajouter manuellement
# La fonction ajout_au_tableau ajoute QUE si la variable n'y est pas encore.
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'REPERTOIRE_DEVELOPPEMENT'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'REPERTOIRE_DES_COMMANDES_PERSO'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'REPERTOIRE_ADMINISTRATIF'
#ajout_au_tableau TABLEAU_VARIABLES_PERSO 'LESSOPEN'
#ajout_au_tableau TABLEAU_VARIABLES_PERSO 'DB_LOCALE'
#ajout_au_tableau TABLEAU_VARIABLES_PERSO 'RACCOURCIS_CLAVIER'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'BASH_PROFILE_PATH'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'BASHRC_PATH'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'BUREAU_PATH'
#ajout_au_tableau TABLEAU_VARIABLES_PERSO 'CORBEILLE_PATH'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'USB_CONNEXION_PATH'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'GUIX_PROFILE'

# Création de la liste des variables persos
LISTE_VARIABLES_PERSO=$( IFS=: ; printf "%s" "${TABLEAU_VARIABLES_PERSO[*]}" )
# transformation du tableau en string séparé par des ":" via la définition de IFS dans un sous-shell
# car impossible de transmettre un tableau en tant que variable d'environnement
export LISTE_VARIABLES_PERSO # pour affichage sur demande via script correspondant







##################################
######### $PATH ##################
##################################

# Liste de paths personnels ajoutés à $PATH
# tableau des paths à ajouter manuellement
declare -a liste_path 
# Mac : ajout_au_tableau liste_path '/usr/local/opt/llvm/bin'
# Mac : ajout_au_tableau liste_path '/usr/local/opt/openjdk/bin'
ajout_au_tableau liste_path "$REPERTOIRE_DES_COMMANDES_PERSO"

### SPECIAL GUIX ####
# Prepend setuid programs.
_path_prepend PATH "/run/setuid-programs"

# Prepend guix à mon PATH
_path_prepend PATH "$HOME/.config/guix/current/bin"

### FIN SPECIAL GUIX

# Ajouter chaque élément du tableau à $PATH
for path_a_ajoute in "${liste_path[@]}"
do
    _path_del PATH "$path_a_ajoute" # supprime les doublons
    _path_append PATH "$path_a_ajoute" # ajoute en fin
done

# Spécial brew
#_path_append PATH /home/linuxbrew/.linuxbrew/bin
#_path_append PATH  /home/linuxbrew/.linuxbrew/sbin


# Commandes GNU placées avant les paths des commandes Apple
# Mac :  _path_prepend PATH "/usr/local/opt/findutils/libexec/gnubin" # GNU findutils avec de multiples commandes de recherche (find / locate ) et aussi xargs
# Mac : _path_prepend PATH "/usr/local/opt/coreutils/libexec/gnubin" # GNU coreutils avec de multiples commandes de traitement de texte
# Mac : _path_prepend PATH "/usr/local/opt/gnu-getopt/bin" # GNU getopt
# Mac : _path_prepend PATH "/usr/local/opt/gnu-sed/libexec/gnubin" # GNU sed
# Mac : _path_prepend PATH "/usr/local/opt/gawk/libexec/gnubin" # GNU awk
# Mac : _path_prepend PATH "/usr/local/opt/grep/libexec/gnubin" # GNU grep
# Linux : _path_del PATH '/usr/local/opt/llvm/bin' 
# Linux : _path_del PATH '/usr/local/opt/openjdk/bin'
# Linux : _path_del PATH "/usr/local/opt/findutils/libexec/gnubin"
# Linux : _path_del PATH "/usr/local/opt/coreutils/libexec/gnubin"
# Linux : _path_del PATH "/usr/local/opt/gnu-getopt/bin"
# Linux : _path_del PATH "/usr/local/opt/gnu-sed/libexec/gnubin"
# Linux : _path_del PATH "/usr/local/opt/gawk/libexec/gnubin"
# Linux : _path_del PATH "/usr/local/opt/grep/libexec/gnubin"

export PATH

##################################
######### FIN PATH ###############
##################################



# Liste des alias ici
# Nom bidon pr tester la création d'un alias
alias affiche_nimporte_quoi_qwjdwfj="printf \"J'affiche nimporte quoi depuis un alias.\n\" ; pwd ; cd ~/Desktop/Developpement ; pwd ; cd $OLDPWD ; pwd ; "
# Fin des alias



# Bidouillage du terminal (visuel / fonctionnalités)
# utile pour le script qui relance la dernière commande avec des espaces.
#clear # nettoyage de l'écran du terminal à chaque lancement de celui-ci
xbindkeys >/dev/null 2>&1 # synchronisation du raccourci clic droit avec la clef -> fichier de config sous $HOME/.xbindkeysrc.scm

# Sauvegarde du profil dans le répertoire des commandes personnelles
TITRE_FICHIER_SAUVEGARDE_PROFIL_BASH="ne_pas_run_fichier_de_sauvegarde_du_contenu_bash_profil"
{ cd $REPERTOIRE_DES_COMMANDES_PERSO &&
cp $BASH_PROFILE_PATH $TITRE_FICHIER_SAUVEGARDE_PROFIL_BASH && # sauvegarde du profile utilisé dans le répertoire perso
cd $OLDPWD ; } || echo -e "Le fichier .profile situé '$BASH_PROFILE_PATH' n'a pas pu être copié dans le répertoire perso.\nDébugger le fichier .profile.\n" >&2 # cd $OLDPWD revient ou j'étais


