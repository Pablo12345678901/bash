# ~/.profile: executed by the command interpreter for login shells.
# This file is not read by bash(1), if ~/.bash_profile or ~/.bash_login
# exists.
# see /usr/share/doc/bash/examples/startup-files for examples.
# the files are located in the bash-doc package.

# the default umask is set in /etc/profile; for setting the umask
# for ssh logins, install and configure the libpam-umask package.
#umask 022

# if running bash
if [ -n "$BASH_VERSION" ]; then
    # include .bashrc if it exists
    if [ -f "$HOME/.bashrc" ]; then
	. "$HOME/.bashrc"
    fi
fi

# set PATH so it includes user's private bin if it exists
if [ -d "$HOME/bin" ] ; then
    PATH="$HOME/bin:$PATH"
fi

# set PATH so it includes user's private bin if it exists
if [ -d "$HOME/.local/bin" ] ; then
    PATH="$HOME/.local/bin:$PATH"
fi


# Profil Linux ci-dessus


# Source le fichier ou je conserve mes fonctions personnelles
# Je l'ai placé dans l'environnement de développement pour faciliter ses modifications.
# Ainsi je peux appeler les fonctions depuis n'importe quel terminal / fichier.
# Toutefois, je dois continuer de sourcer le fichiers dans mes scripts.
: ${REPERTOIRE_DES_COMMANDES_PERSO:="$HOME/Bureau/Developpement/bash/bin"} # fixe la variable si pas définie
. $REPERTOIRE_DES_COMMANDES_PERSO/fonctions_personnelles # source les fonctions personnelles



# Contrôle pour ne pas run ce script par moi-même via mes commandes personnelles.
if [[ $0 =~ (-)?bash$ ]] # "-bash" est run au lancement et "bash" est run avec "exec bash -l" qui relance bash
then
    :
else
    CE_FICHIER="$0"
    COMMANDE_APPELEE=$(basename $CE_FICHIER) # Obtention du nom du fichier en supprimant le reste du path
    echo -e "\nErreur : vous ne devez pas run la commande (script) \"$COMMANDE_APPELEE\" car ce script est une copie du profil de Bash sauvegardée dans le fichier .profile et sert uniquement à la sauvegarde pour être réutilisée en cas de changement d'environnement.\n"
    exit 1 # exit du fichier si ce n'est pas le shell qui le run à l'ouverture
    # c'est-à-dire : exit du fichier si je le run sous le nom donné ci-dessous en tant que commande du dossier personnel.
fi






# Fonction pour éviter un ajout de path à double dans $PATH
################################
# _remove $1 from PATH
function _path_del() {
    local -n VAR_A_MODIF_DEL=$1
    local _l=":$VAR_A_MODIF_DEL:"
    # $2 = path à supprimer
    while [[ $_l =~ :$2: ]]; do
          _l=${_l//:$2:/:}
    done
    _l=${_l%:}
    _l=${_l#:}
    VAR_A_MODIF_DEL="$_l"
}

# _prepend : prepend $1 to PATH.
function _path_prepend() {
    local -n VAR_A_MODIF_PREPEND=$1
    # $2 : le path à ajouter
    _path_del PATH "$2"
    VAR_A_MODIF_PREPEND="$2:$VAR_A_MODIF_PREPEND"
}

# _append : append $1 to PATH.
function _path_append() {
    local -n VAR_A_MODIF_APPEND=$1
    # $2 : le path à ajouter
    _path_del VAR_A_MODIF_APPEND "$2"
    if [ -z "$VAR_A_MODIF_APPEND" ] # if lenght is 0
    then
        VAR_A_MODIF_APPEND="$2" # adding path without separator
    else
        VAR_A_MODIF_APPEND="$VAR_A_MODIF_APPEND:$2" # adding path with separator ':' before
    fi
}

# ajout_element_tableau : argument 1 = tableau / argument 2 = élément à ajouter
function ajout_au_tableau() {
    if [[ -z "$1" || -z "$2" ]]
    then
        echo "ERREUR : les arguments \$1 : nom_du_tableau_en_string et \$2 : élément à ajouter au tableau n'ont pas été fourni tous les 2."
    else
        local -n tableau=$1
        # Contrôle si l'élément est déjà dans le tableau et ajout s'il n'y est pas.
        if [[ " ${tableau[*]} " =~ " ${2} " ]]
        # Les éléments sont séparés par des espaces.
        # Sauf en début et fin.
        # Donc pour contrôler le REGEX, ajout d'espace avant et après.
        then
            : # si l'élément est déjà dans le tableau on ne le rajoute pas
        else
            tableau+=("$2")
        fi
    fi
}


# Fonctions diverses :
# X



################################
# Liste variables d'environnement personnelles (créées par moi)
REPERTOIRE_DEVELOPPEMENT="$HOME/Bureau/Developpement"
export REPERTOIRE_DEVELOPPEMENT # pour utilisation (notamment) durant les push de Git
REPERTOIRE_DES_COMMANDES_PERSO="$REPERTOIRE_DEVELOPPEMENT/bash/bin" # path du répertoire des commandes perso - à adapter si changement d'environnement
export REPERTOIRE_DES_COMMANDES_PERSO # pour utilisation dans le script qui sauvegarde ce profil
REPERTOIRE_ADMINISTRATIF="$REPERTOIRE_DEVELOPPEMENT/administratif"
export REPERTOIRE_ADMINISTRATIF
# Pour lesspipe, une extension utile à la commande less de Bash
LESSOPEN="|/usr/local/bin/lesspipe.sh %s"
export LESSOPEN
# Pour la commande ajouter la database locale à la commande locate
DB_LOCALE="$HOME/locate.user.database"
export DB_LOCALE
# Pour la gestion des keybinds (raccourcis clavier) de la commande 'bind'
RACCOURCIS_CLAVIER="$REPERTOIRE_DES_COMMANDES_PERSO/bind_gestion_raccourci_clavier.txt"
export RACCOURCIS_CLAVIER
# Path du fichier de profil bash
BASH_PROFILE_PATH="$HOME/.profile"
export BASH_PROFILE_PATH
# Path du fichier bashrc
BASHRC_PATH="$HOME/.bashrc"
export BASHRC_PATH
# Path du bureau
BUREAU_PATH="$HOME/Bureau"
export BUREAU_PATH
# Path de la corbeille 
CORBEILLE_PATH="$HOME/.local/share/Trash"
export CORBEILLE_PATH
# Path de connexion des ports usb locaux
USB_CONNEXION_PATH="/media/${USER}"
export USB_CONNEXION_PATH

# Tableau des variables personnelles 
declare -a TABLEAU_VARIABLES_PERSO # tableau des paths à ajouter manuellement
# La fonction ajout_au_tableau ajoute QUE si la variable n'y est pas encore.
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'REPERTOIRE_DEVELOPPEMENT'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'REPERTOIRE_DES_COMMANDES_PERSO'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'REPERTOIRE_ADMINISTRATIF'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'LESSOPEN'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'DB_LOCALE'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'RACCOURCIS_CLAVIER'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'BASH_PROFILE_PATH'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'BASHRC_PATH'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'BUREAU_PATH'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'CORBEILLE_PATH'
ajout_au_tableau TABLEAU_VARIABLES_PERSO 'USB_CONNEXION_PATH'

# Création de la liste des variables persos
LISTE_VARIABLES_PERSO=$( IFS=: ; printf "%s" "${TABLEAU_VARIABLES_PERSO[*]}" )
# transformation du tableau en string séparé par des ":" via la définition de IFS dans un sous-shell
# car impossible de transmettre un tableau en tant que variable d'environnement
export LISTE_VARIABLES_PERSO # pour affichage sur demande via script correspondant







##################################
######### $PATH ##################
##################################

# Liste de paths personnels ajoutés à $PATH
# tableau des paths à ajouter manuellement
declare -a liste_path 
# Mac : ajout_au_tableau liste_path '/usr/local/opt/llvm/bin'
# Mac : ajout_au_tableau liste_path '/usr/local/opt/openjdk/bin'
ajout_au_tableau liste_path "$REPERTOIRE_DES_COMMANDES_PERSO"


# Ajouter chaque élément du tableau à $PATH
for path_a_ajoute in "${liste_path[@]}"
do
    _path_del PATH "$path_a_ajoute" # supprime les doublons
    _path_append PATH "$path_a_ajoute" # ajoute en fin
done

# Spécial brew
_path_append PATH /home/linuxbrew/.linuxbrew/bin
_path_append PATH  /home/linuxbrew/.linuxbrew/sbin


# Commandes GNU placées avant les paths des commandes Apple
# Mac :  _path_prepend PATH "/usr/local/opt/findutils/libexec/gnubin" # GNU findutils avec de multiples commandes de recherche (find / locate ) et aussi xargs
# Mac : _path_prepend PATH "/usr/local/opt/coreutils/libexec/gnubin" # GNU coreutils avec de multiples commandes de traitement de texte
# Mac : _path_prepend PATH "/usr/local/opt/gnu-getopt/bin" # GNU getopt
# Mac : _path_prepend PATH "/usr/local/opt/gnu-sed/libexec/gnubin" # GNU sed
# Mac : _path_prepend PATH "/usr/local/opt/gawk/libexec/gnubin" # GNU awk
# Mac : _path_prepend PATH "/usr/local/opt/grep/libexec/gnubin" # GNU grep
# Linux : _path_del PATH '/usr/local/opt/llvm/bin' 
# Linux : _path_del PATH '/usr/local/opt/openjdk/bin'
# Linux : _path_del PATH "/usr/local/opt/findutils/libexec/gnubin"
# Linux : _path_del PATH "/usr/local/opt/coreutils/libexec/gnubin"
# Linux : _path_del PATH "/usr/local/opt/gnu-getopt/bin"
# Linux : _path_del PATH "/usr/local/opt/gnu-sed/libexec/gnubin"
# Linux : _path_del PATH "/usr/local/opt/gawk/libexec/gnubin"
# Linux : _path_del PATH "/usr/local/opt/grep/libexec/gnubin"

export PATH

##################################
######### FIN PATH ###############
##################################



# Liste des alias ici
# Nom bidon pr tester la création d'un alias
alias affiche_nimporte_quoi_qwjdwfj="printf \"J'affiche nimporte quoi depuis un alias.\n\" ; pwd ; cd ~/Desktop/Developpement ; pwd ; cd $OLDPWD ; pwd ; "
# Fin des alias



# Bidouillage du terminal (visuel / fonctionnalités)
# utile pour le script qui relance la dernière commande avec des espaces.
clear # nettoyage de l'écran du terminal à chaque lancement de celui-ci


# Sauvegarde du profil dans le répertoire des commandes personnelles
TITRE_FICHIER_SAUVEGARDE_PROFIL_BASH="ne_pas_run_fichier_de_sauvegarde_du_contenu_bash_profil"
{ cd $REPERTOIRE_DES_COMMANDES_PERSO &&
cp $BASH_PROFILE_PATH $TITRE_FICHIER_SAUVEGARDE_PROFIL_BASH && # sauvegarde du profile utilisé dans le répertoire perso
cd $OLDPWD ; } || echo -e "Le fichier .profile situé '$BASH_PROFILE_PATH' n'a pas pu être copié dans le répertoire perso.\nDébugger le fichier .profile.\n" >&2 # cd $OLDPWD revient ou j'étais


