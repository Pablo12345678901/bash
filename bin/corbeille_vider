#!/usr/bin/env bash

# Syntaxe :
# - : pas d'argument à fournir

source fonctions_personnelles

declare -a TABLEAU_PATH_NON_TRIES # pour la suppression (non trié)
declare -a TABLEAU_PATH # pour la suppression (trié)
declare -a TABLEAU_FICHIERS_NON_TRIES # pour l'affichage initial (non trié)
declare -a TABLEAU_FICHIERS # pour l'affichage initial
declare -a TABLEAU_FICHIERS_RESTANTS # pour l'affichage final

PATH_CORBEILLE=$CORBEILLE_PATH/*

# Obtention de la liste des fichiers initiaux (corbeille)
while read OUTPUT
do
    TABLEAU_PATH_NON_TRIES=( "${TABLEAU_PATH_NON_TRIES[@]}" "$OUTPUT" ) # ajoute la nouvelle valeur à la suite des valeurs actuelles
    TABLEAU_FICHIERS_NON_TRIES=( "${TABLEAU_FICHIERS_NON_TRIES[@]}" "$(basename "$OUTPUT")" ) # ajoute la nouvelle valeur à la suite des valeurs actuelles
done < <(find -s $PATH_CORBEILLE -print 2>/dev/null | xargs -0 )

# Si disque dur est connecté, (et donc le fichier de la corbeille existant)
# obtention de la liste des fichiers initiaux de la corbeille du disque dur
CORBEILLE_DISQUE_DUR="/Volumes/Elements/.Trashes/501"
FLAG_CORBEILLE_DISQUE_DUR="false"
FLAG_AFFICHAGE_UNIQUE="true"
if [ -e "$CORBEILLE_DISQUE_DUR" ]
then
    FLAG_CORBEILLE_DISQUE_DUR="true"
    PATH_CORBEILLE_DISQUE_DUR=$CORBEILLE_DISQUE_DUR/*
    while read OUTPUT
    do
        TABLEAU_PATH_NON_TRIES=( "${TABLEAU_PATH_NON_TRIES[@]}" "$OUTPUT" ) # ajoute la nouvelle valeur à la suite des valeurs actuelles
        TABLEAU_FICHIERS_NON_TRIES=( "${TABLEAU_FICHIERS_NON_TRIES[@]}" "$(basename "$OUTPUT")" ) # ajoute la nouvelle valeur à la suite des valeurs actuelles
    done < <(find -s $PATH_CORBEILLE_DISQUE_DUR -print 2>/dev/null | xargs -0 )
else
    : # ne rien faire si pas connecté
fi


# Tri par ordre alphabétique - pr un affichage esthétique ensuite
tableau_trier_ordre_alphabetique_pas_numero TABLEAU_PATH_NON_TRIES TABLEAU_PATH
tableau_trier_ordre_alphabetique_pas_numero TABLEAU_FICHIERS_NON_TRIES TABLEAU_FICHIERS
#tableau_contenu TABLEAU_PATH #DEBUG
#tableau_contenu TABLEAU_FICHIERS #DEBUG

# Besoin d'une gestion du message corbeille vide ou liste fichier
echo -e "BUG : TROP DE FICHIER DANS LE TABLEAU (2 DE PLUS)"
COMPTEUR=0 # DEBUG
if [ ${#TABLEAU_FICHIERS[@]} -eq 0 ]
then
    echo -e "\nLa corbeille est déjà vide...\n"
    exit 0
else
    echo -e "\nListe des fichiers dans la corbeille :"
    #tableau_contenu TABLEAU_FICHIERS
    for FIFICHIER in "${TABLEAU_FICHIERS[@]}"
    do
        ((COMPTEUR++))
        echo "$COMPTEUR $FIFICHIER"
    done
    echo "" # retour à la ligne esthétique
fi

#tableau_taille TABLEAU_FICHIERS
echo -e "\nEN COURS DE DEV\n"
# Besoin débugguer le nombre de fichier ci-dessus
# Et gérer les fichiers corbeille disque dur ci-dessous avec le flag
# car besoin d'y faire que s'il y a disque dur
exit 0


# Vidage corbeille
echo -e "\nVidage de la corbeille..."
for file in "${TABLEAU_PATH[@]}"
do
    filename="${file##*/}"
    # Tentative de suppression
    rm -fr "$file" ||
    { echo -e "\nERREUR : le fichier \"$filename\" n'a pas pu être supprimé.\n" && continue ; }
    # Affichage du fichier que si supprimé
    echo "$filename"
done

# Obtention de la liste des fichiers finaux
while read OUTPUT; do
  TABLEAU_FICHIERS_RESTANTS=( "${TABLEAU_FICHIERS_RESTANTS[@]}" "$OUTPUT" ) # ajoute la nouvelle valeur à la suite des valeurs actuelles
done < <(find $PATH_CORBEILLE -print0 2>/dev/null | xargs -0 basename )

if [ ${#TABLEAU_FICHIERS_RESTANTS[@]} -eq 0 ]
then
    echo -e "\nLa corbeille a été vidée.\n"
    exit 0
else
    echo -e "\nERREUR : La corbeille n'a pas pu être vidée.\n"
    echo -e "Voici la liste des fichiers à supprimer manuellement (ou contrôler le script) :"
    for element in "${TABLEAU_FICHIERS_RESTANTS[@]}"
    do
        echo "\"$element\""
    done
    echo ""
    exit 1
fi
