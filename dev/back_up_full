#!/usr/bin/env bash

# Syntax :
# -

source functions_personal

# Set the list of target directories for the back-up through their environment variable name
declare -a ARRAY_DIR_LIST_FOR_BACK_UP
ARRAY_DIR_LIST_FOR_BACK_UP+=("DIR_BACK_UP_PROFILES")
ARRAY_DIR_LIST_FOR_BACK_UP+=("DIR_BACK_UP_SYSTEM_CONFIG")
ARRAY_DIR_LIST_FOR_BACK_UP+=("DIR_BACK_UP_CHANNELS")
ARRAY_DIR_LIST_FOR_BACK_UP+=("DIR_BACK_UP_MANIFESTS")
ARRAY_DIR_LIST_FOR_BACK_UP+=("DIR_BACK_UP_PARTITION")

# Set the list of profile files to back-up through their environment variable name
declare -a ARRAY_ENV_VAR_PROFILES_FILES
ARRAY_ENV_VAR_PROFILES_FILES+=("BASH_PROFILE")
ARRAY_ENV_VAR_PROFILES_FILES+=("BASHRC")
ARRAY_ENV_VAR_PROFILES_FILES+=("EMACS_CONF")
ARRAY_ENV_VAR_PROFILES_FILES+=("GIT_CONF")
ARRAY_ENV_VAR_PROFILES_FILES+=("PROXYCHAINS_CONF")
ARRAY_ENV_VAR_PROFILES_FILES+=("RBW_CONF")

# Path for output file
SCRIPT_OUTPUT_FILE="${REPERTOIRE_TEMPORAIRE}/output.txt"
# Will enable the user to read the message before running a long command of back-up with external disk
PAUSE_BEFORE_RUN=5 

# Check that all back-up directories exist
for i in "${!ARRAY_DIR_LIST_FOR_BACK_UP[@]}"
do
    if [ ! -d "${!ARRAY_DIR_LIST_FOR_BACK_UP[$i]}" ]
    then
        # Exit with error else
	STDERR_show_message "\nERROR : the variable for the back-up directory \"${ARRAY_DIR_LIST_FOR_BACK_UP[$i]}\" is not correctly set. Currently, its value is \"${!ARRAY_DIR_LIST_FOR_BACK_UP[$i]}\" which is not a directory.\n"
        exit 1
    fi
done

#######################################################################
################### BACK UP OF MAIN FILES #############################
#######################################################################

# Back-up of profiles files
for i in "${!ARRAY_ENV_VAR_PROFILES_FILES[@]}"
do
    # Check that the file exists through its environment variable value
    if [ ! -f "${!ARRAY_ENV_VAR_PROFILES_FILES[$i]}" ]
    then
	# Exit with error else
	STDERR_show_message "\nERROR : The environment variable \"${ARRAY_ENV_VAR_PROFILES_FILES[$i]}\" is not correctly set. Currently, its value is \"${!ARRAY_ENV_VAR_PROFILES_FILES[$i]}\" which is not a file.\n"
	  exit 1
    fi

    # Back-up with confirmation of success / error through another script
    back_up_files_to_dir_with_timestamp -f  "${!ARRAY_ENV_VAR_PROFILES_FILES[$i]}" -d "$DIR_BACK_UP_PROFILES" ||
	exit 1

done

# Back-up of system configuration
# Check that the file exists
if [ ! -f "$GUIX_SYSTEM_CONF" ]
then
    # Exit with error else
    STDERR_show_message "\nERROR : The environment variable \"GUIX_SYSTEM_CONF\" is not correctly set. Currently, its value is \"$GUIX_SYSTEM_CONF\" which is not a file.\n"
      exit 1
else
# Back-up with confirmation of success / error through another script
back_up_files_to_dir_with_timestamp -f  "$GUIX_SYSTEM_CONF" -d "$DIR_BACK_UP_SYSTEM_CONFIG" ||
    exit 1
fi

# Back-up of channels configuration
# Check that the file exists
if [ ! -f "$GUIX_CHANNELS_CONF" ]
then
    # Exit with error else
    STDERR_show_message "\nERROR : The environment variable \"GUIX_CHANNELS_CONF\" is not correctly set. Currently, its value is \"$GUIX_CHANNELS_CONF\" which is not a file.\n"
      exit 1
else
# Back-up with confirmation of success / error through another script
back_up_files_to_dir_with_timestamp -f  "$GUIX_CHANNELS_CONF" -d "$DIR_BACK_UP_CHANNELS" ||
    exit 1
fi

# Back-up of current packages list
# Check if the file exists (it is a symlink) so not using '-f'
if [ ! -e "$GUIX_PACKAGES_INSTALLATION_PROFILE" ]
then
    # Exit with error else
    STDERR_show_message "\nERROR : The environment variable \"GUIX_PACKAGES_INSTALLATION_PROFILE\" is not correctly set. Currently, its value is \"$GUIX_PACKAGES_INSTALLATION_PROFILE\" which does not exist.\n"
      exit 1
else
    # Back-up with confirmation of success / error
    {  BACK_UP_MANIFEST_PATH="${DIR_BACK_UP_MANIFESTS}/$(timestamp_current)-manifest.scm" &&
	# Write a new file with the manifest of current packages.
	guix package -p "$GUIX_PACKAGES_INSTALLATION_PROFILE" --export-manifest > "$BACK_UP_MANIFEST_PATH" &&
      echo -e "\nOK - The manifest of current packages was saved under the path \"$BACK_UP_MANIFEST_PATH\".\n"
    }||
    { STDERR_show_message "\nERROR : The manifest of current packages could not be backed-up. Check script output and/or the back-up script.\n"
      exit 1
    }
fi

#######################################################################
############ BACK UP OF PARTITION AND FILESYSTEM ######################
#######################################################################

# Back-up of disk-partition, size and filesystem types

# 'lsblk' to get the list of partitions as well as their sizes.
COMMAND_TO_RUN="lsblk"
# Get a string without space to be used within the back-up filename
# Step useful if further evolution of the command
COMMAND_STRING_WITHOUT_SPACE="$(echo "$COMMAND_TO_RUN" | tr ' ' '_')"
# Back-up with confirmation of success / error
{  BACK_UP_PATH="${DIR_BACK_UP_PARTITION}/$(timestamp_current)_$COMMAND_STRING_WITHOUT_SPACE" &&
   # Write a new file with the partition.
   $COMMAND_TO_RUN > "$BACK_UP_PATH" &&
   echo -e "\nOK - The partition shown with the command '$COMMAND_TO_RUN' was saved under the path \"$BACK_UP_PATH\".\n"
}||
{ STDERR_show_message "\nERROR : The partition shown with the command '$COMMAND_TO_RUN' could not be backed-up. Check script output and/or the back-up script.\n"
  exit 1
}

# 'lsblk -f' to get the filesystem types of the partitions    
COMMAND_TO_RUN="lsblk -f"
# Get a string without space to be used within the back-up filename
COMMAND_STRING_WITHOUT_SPACE="$(echo "$COMMAND_TO_RUN" | tr ' ' '_')"
# Back-up with confirmation of success / error
{  BACK_UP_PATH="${DIR_BACK_UP_PARTITION}/$(timestamp_current)_$COMMAND_STRING_WITHOUT_SPACE" &&
   # Write a new file with the partition.
   $COMMAND_TO_RUN > "$BACK_UP_PATH" &&
   echo -e "\nOK - The partition shown with the command '$COMMAND_TO_RUN' was saved under the path \"$BACK_UP_PATH\".\n"
}||
{ STDERR_show_message "\nERROR : The partition shown with the command '$COMMAND_TO_RUN' could not be backed-up. Check script output and/or the back-up script.\n"
  exit 1
}

#######################################################################
####### BACK UP OF CONTENT OF $HOME SUBDIRECTORIES ####################
#######################################################################

# Warning for user to check the content of the directories under $HOME to back-up if required.
# Add main $HOME sub-directories within an array
declare -a ARRAY_OF_BASENAME_OF_DIRECTORIES_UNDER_HOME
ARRAY_OF_BASENAME_OF_DIRECTORIES_UNDER_HOME+=("Desktop")
ARRAY_OF_BASENAME_OF_DIRECTORIES_UNDER_HOME+=("Documents")
ARRAY_OF_BASENAME_OF_DIRECTORIES_UNDER_HOME+=("Downloads")
ARRAY_OF_BASENAME_OF_DIRECTORIES_UNDER_HOME+=("Music")
ARRAY_OF_BASENAME_OF_DIRECTORIES_UNDER_HOME+=("Pictures")
ARRAY_OF_BASENAME_OF_DIRECTORIES_UNDER_HOME+=("Public")
ARRAY_OF_BASENAME_OF_DIRECTORIES_UNDER_HOME+=("Templates")
ARRAY_OF_BASENAME_OF_DIRECTORIES_UNDER_HOME+=("Videos")
ARRAY_OF_BASENAME_OF_DIRECTORIES_UNDER_HOME+=("Wallpapers")

# Loop on them
for EACH_BASENAME in "${ARRAY_OF_BASENAME_OF_DIRECTORIES_UNDER_HOME[@]}"
do
    DIRECTORY_PATH="${HOME}/${EACH_BASENAME}"
    # Test if they exists on current OS, if so, adapt the string that will be used in the message below
    if [ -d "$DIRECTORY_PATH" ]
    then
	STRING_OF_DIRECTORIES_TO_CHECK="${STRING_OF_DIRECTORIES_TO_CHECK}
    - $EACH_BASENAME (located \"$DIRECTORY_PATH\")"
    fi
done

# Show the message for the user to require the manual back-up of those directories content
read -p "TO DO :
1. Control the content of the directories under \$HOME.
2. Save all important files within the git directories.

For example, a non-exaustive list of those directories :
$STRING_OF_DIRECTORIES_TO_CHECK

Please confirm when done by typing 'enter'.
" 



#######################################################################
############ BACK UP OF DEVELOPMENT GIT REPO ##########################
#######################################################################

# Get all my personal git directories within an array
declare -a ARRAY_OF_GIT_DIRECTORIES
ARRAY_OF_GIT_DIRECTORIES=($(find "$REPERTOIRE_DEVELOPPEMENT" -maxdepth 1 -mindepth 1))
# Sort the directories
declare -a SORTED_ARRAY_OF_GIT_DIRECTORIES
tableau_trier_ordre_alphabetique_pas_numero ARRAY_OF_GIT_DIRECTORIES SORTED_ARRAY_OF_GIT_DIRECTORIES

# Loop on them to create a pretty string for the next message
for EACH_GIT_DIRECTORY in "${SORTED_ARRAY_OF_GIT_DIRECTORIES[@]}"
do
    EACH_GIT_DIRECTORY_BASENAME="${EACH_GIT_DIRECTORY##*/}"
    STRING_OF_GIT_DIRECTORIES="${STRING_OF_GIT_DIRECTORIES}
    - $EACH_GIT_DIRECTORY_BASENAME (located \"$EACH_GIT_DIRECTORY\")"
done

# Show the message for the user to require to save current development environment (if wished).
read -p "TO DO :
1. Save current development environment content of the git directories.

List of those directories :
$STRING_OF_GIT_DIRECTORIES

Please confirm when done by typing 'enter'.
" 

# Force commit and/or push all personal git repo through another script
# And process the exit if any error occurs.
git_force_update_all || exit 1

echo -e "\nDEBUG EXIT 55\n"
exit 55

: <<"CURRENTLYINDEV"


: <<"GITPARTINDEV"

# TO BE DONE LATER

# See the detailed list of steps in the back_up_checklist file (some were added).

4. Git dirs :
    - Check on my git userspace (login) that all git push were well performed.
    - Copy content of files/dir in .gitignore in a temporary directory (they will be losed else.
    - Remove all git dirs locally.
    - Remove the token to avoid security issue.
    - Create a new token.
    - Note it in order to use it.
    - If stay on the same OS :
        - reclone required Git repos.
	- Add data ignored by .gitignore file into the repo new directory from my temporary dir.
    - Clone my git repos into my external disk to save the content in case my GitHub is hacked.

# Git
# Ask if the development environment were saved
# If yes, then push all directories
# Ask the user to check git login space to check that the git push were well done.
# Only after this all, remove all git directories

# Require to remove the token

# List here the required git repository to clone in the development environment AND whether or not they are mine (to add the token)
# Require for the news token
# Clone the git dirs with urls provided and the token before if they are mine > can check it by greping the url to see if it contains my github name

GITPARTINDEV

#######################################################################
################## PURGE OF RBW DATABASE ##############################
#######################################################################

# Purge local Bitwarden database (tool 'rbw')
{ rbw purge &&
  echo -e "\nOK : The local Bitwarden database was sucessfully purged.\n"
} ||
{    STDERR_show_message "\nERROR : The local Bitwarden database could not be purged. Check script output and/or do it manually...\n"
     exit 1
}

#######################################################################
################## BACK-UP OF EXTERNAL DISKS  #########################
#######################################################################

# Ask HERE the user to connect both disk OR exit if wished
# Check first if main external disk is connected - because some steps does not need secondary disk
# Then after, those, check if secondary disk is connected for the steps requiring it.

# Back-up of external disk
# Check if env var are okay and if the external disks are connected - else exit with error
if [[ ! -d "$USB_MAIN_EXTERNAL_DRIVE" || ! -d "$USB_SECONDARY_EXTERNAL_DRIVE" || ! -d "$REPERTOIRE_TEMPORAIRE" ]]
then
    echo -e "\nERROR : one (or more) of those var below is not correctly defined."
    echo -e "USB_MAIN_EXTERNAL_DRIVE = \"$USB_MAIN_EXTERNAL_DRIVE\""
    echo -e "USB_SECONDARY_EXTERNAL_DRIVE = \"$USB_SECONDARY_EXTERNAL_DRIVE\""
    echo -e "SCRIPT_OUTPUT_FILE = \"$SCRIPT_OUTPUT_FILE\""
    
    echo -e "Its is maybe because of the env var below :"
    echo -e "USB_CONNEXION_PATH = \"$USB_CONNEXION_PATH\""
    echo -e "REPERTOIRE_TEMPORAIRE = \"$REPERTOIRE_TEMPORAIRE\""
    echo "" # Esthetic
    exit 1
fi

# Remove content if file existing
echo -n "" > "$SCRIPT_OUTPUT_FILE"

# The below part will be set as optional

: <<"GITBACKUPINTOEXTERNALDISK"
# Copy all my git repo to main external disk : back-up in case GitHub server crash.
GITBACKUPINTOEXTERNALDISK

# The below part will be set as optional
: <<"SETOPTIONALHEREINDEV"
SETOPTIONALHEREINDEV

# Back-up of main external disk to secondary one
COMMAND="sudo back_up_a_dir_to_another -s ${USB_MAIN_EXTERNAL_DRIVE}/ -d ${USB_SECONDARY_EXTERNAL_DRIVE} "

# Show the current step
echo -e "\nBacking-up the main external disk to the secondary one...\n" &&
# Pause X seconds to let the user read the message
sleep $PAUSE_BEFORE_RUN

# Back-up
{ $COMMAND &&
      echo "OK - COMMAND \"$COMMAND\"" >> "$SCRIPT_OUTPUT_FILE"
} || echo "ERROR - COMMAND \"$COMMAND\"" >> "$SCRIPT_OUTPUT_FILE"
echo -e "\n\n" >> "$SCRIPT_OUTPUT_FILE" # Esthetic

# Showing the results
echo -e "\nBack-up of external disks finished - Please check the results.\n"
file_open -f "$SCRIPT_OUTPUT_FILE"
